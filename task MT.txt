
/*«адача #1
≈сть "сервер" в виде статического класса.
” него есть переменна€ count (тип int) и два метода, которые позвол€ют эту переменную читать и писать: GetCount() и AddToCount(int value).
  серверу стучатс€ множество параллельных клиентов, которые в основном читают, но некоторые добавл€ют значение к count.

Ќужно реализовать GetCount / AddToCount так, чтобы:
читатели могли читать параллельно, без выстраивани€ в очередь по локу;
писатели писали только последовательно и никогда одновременно;
пока писатели добавл€ют и пишут, читатели должны ждать окончани€ записи.
*/

/*«адача #2
¬ .net есть возможность звать делегаты как синхронно:
EventHandler h = new EventHandler(this.myEventHandler);
h.Invoke(null, EventArgs.Empty);
так и асинхронно:
var res = h.BeginInvoke(null, EventArgs.Empty, null, null);

Ќужно реализовать возможность полусинхронного вызова делегата (написать реализацию класса AsyncCaller), который бы работал таким образом:

EventHandler h = new EventHandler(this.myEventHandler);
ac = new AsyncCaller(h);
bool completedOK = ac.Invoke(5000, null, EventArgs.Empty);

"ѕолусинхронного" в данном случае означает, что делегат будет вызван, и вызывающий поток будет ждать, пока вызов не выполнитс€. 
Ќо если выполнение делегата займет больше 5000 миллисекунд, то ac.Invoke выйдет и вернет в completedOK значение false.
*/